-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/AdamLassiter/lambda-cube#readme</a>
@package lambda-cube
@version 0.1.1.0

module L3.Util
type Result a = Either String a
throwError :: String -> Result a
unpack :: [Result a] -> Result [a]
mapL :: (String -> String) -> Result a -> Result a
mapR :: (a -> b) -> Result a -> Result b
fmapR :: (a -> Result b) -> Result a -> Result b
flatten :: Result (Result a) -> Result a
throwL :: Result a -> a
converge :: Eq a => (a -> a) -> a -> a
logU :: IO String -> Priority -> String -> IO ()
debugU :: IO String -> String -> IO ()
infoU :: IO String -> String -> IO ()
noticeU :: IO String -> String -> IO ()
warningU :: IO String -> String -> IO ()
errorU :: IO String -> String -> IO ()
criticalU :: IO String -> String -> IO ()
alertU :: IO String -> String -> IO ()
emergencyU :: IO String -> String -> IO ()

module L3.Parsec
newtype Parser i o
Parser :: (i -> [(o, i)]) -> Parser i o
[parse] :: Parser i o -> i -> [(o, i)]
runParser :: (Alternative f, Show (f i), Show o, Eq (f i)) => Parser (f i) o -> f i -> Result o
bind :: Parser i o -> (o -> Parser i o') -> Parser i o'
unit :: o -> Parser i o
combine :: Parser i o -> Parser i o -> Parser i o
failure :: Parser i o
option :: Parser i o -> Parser i o -> Parser i o
some :: Alternative f => f a -> f [a]
many :: Alternative f => f a -> f [a]
chainl :: Parser i o -> Parser i (o -> o -> o) -> o -> Parser i o
chainl1 :: Parser i o -> Parser i (o -> o -> o) -> Parser i o
instance GHC.Base.Functor (L3.Parsec.Parser i)
instance GHC.Base.Applicative (L3.Parsec.Parser i)
instance GHC.Base.Monad (L3.Parsec.Parser i)
instance GHC.Base.MonadPlus (L3.Parsec.Parser i)
instance GHC.Base.Alternative (L3.Parsec.Parser i)

module L3.StringParsec
item :: Parser String Char
satisfy :: (Char -> Bool) -> Parser String Char
oneOf :: String -> Parser String Char
char :: Char -> Parser String Char
letter :: Parser String Char
natural :: Parser String Integer
string :: String -> Parser String String
token :: Parser String a -> Parser String a
reserved :: String -> Parser String String
space :: Parser String Char
spaces :: Parser String String
digit :: Parser String Char
number :: Parser String Int
word :: Parser String String
parens :: Parser String a -> Parser String a

module L3.Lexer
data Token
OpenParen :: Token
CloseParen :: Token
HasType :: Token
At :: Token
StarT :: Token
BoxT :: Token
Arrow :: Token
LambdaT :: Token
PiT :: Token
Symbol :: String -> Token
Number :: Int -> Token
Comment :: String -> Token
EOL :: Token
alternatives :: [Parser String Token]
comment :: Parser String Token
lexSrc :: String -> Result [Token]
grammar :: Parser String [Token]
instance GHC.Classes.Eq L3.Lexer.Token
instance GHC.Show.Show L3.Lexer.Token

module L3.TokenParsec
item :: Parser [Token] Token
satisfy :: (Token -> Bool) -> Parser [Token] Token
one :: Token -> Parser [Token] Token
oneOf :: [Token] -> Parser [Token] Token
token :: Parser [Token] a -> Parser [Token] a
reserved :: Token -> Parser [Token] Token
number :: Parser [Token] Token
symbol :: Parser [Token] Token
parens :: Parser [Token] a -> Parser [Token] a

module L3.Core
type ShowCtx = Context Name
type ShowExpr = Expr Name
newtype Name
Name :: String -> Name
type Context a = [(a, Expr a)]
data Expr a
Star :: Expr a
Box :: Expr a
Var :: a -> Expr a
Lam :: a -> Expr a -> Expr a -> Expr a
Pi :: a -> Expr a -> Expr a -> Expr a
App :: Expr a -> Expr a -> Expr a
showExpr :: ShowExpr -> String
prettyShowCtx :: ShowCtx -> String
showCtx :: Show a => Context a -> String
free :: Eq a => a -> Expr a -> Bool
substitute :: Eq a => a -> Expr a -> Expr a -> Expr a
normalize :: Eq a => Expr a -> Expr a
normalize0 :: Eq a => Expr a -> Expr a
index :: Eq a => Int -> Expr (Either Int a) -> Expr (Either Int a)
index0 :: Eq a => Expr a -> Expr (Either Int a)
alphaEq :: Eq a => Expr a -> Expr a -> Bool
betaEq :: Eq a => Expr a -> Expr a -> Bool
evalExpr1 :: (Eq a, Show a) => Context a -> Expr a -> Result (Expr a, Expr a)
inferType :: (Eq a, Show a) => Context a -> Expr a -> Result (Expr a)
inferType0 :: (Eq a, Show a) => Expr a -> Result (Expr a)
wellTyped :: (Eq a, Show a) => Context a -> Expr a -> Bool
wellTyped0 :: (Eq a, Show a) => Expr a -> Bool
instance Data.Foldable.Foldable L3.Core.Expr
instance GHC.Base.Functor L3.Core.Expr
instance Data.Traversable.Traversable L3.Core.Expr
instance GHC.Show.Show a => GHC.Show.Show (L3.Core.Expr a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (L3.Core.Expr a)
instance GHC.Classes.Eq L3.Core.Name
instance GHC.Show.Show L3.Core.Name

module L3.Parser
parseExpr :: [Token] -> Result ShowExpr
sugarE :: Parser [Token] ShowExpr
appE :: Parser [Token] ShowExpr
funE :: Parser [Token] ShowExpr
termE :: Parser [Token] ShowExpr
arrE :: Parser [Token] (Name, ShowExpr)
typE :: Parser [Token] (Name, ShowExpr)
star :: Parser [Token] ShowExpr
box :: Parser [Token] ShowExpr
var :: Parser [Token] ShowExpr
nsVar :: Parser [Token] ShowExpr
lamE :: Parser [Token] ShowExpr
piE :: Parser [Token] ShowExpr
anonPiE :: Parser [Token] ShowExpr

module L3.Loader
takeDirectoryName :: FilePath -> String
takeNamespacedFileName :: FilePath -> String
embeddedPrelude :: [(FilePath, ByteString)]
loadPrelude :: (ShowCtx, ShowCtx)
wrapPrelude :: (ShowCtx, ShowExpr -> ShowExpr)
