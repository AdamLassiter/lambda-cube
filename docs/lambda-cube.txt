-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Some thoughts on Calculus of Constructions
--   
--   Please see the README on GitHub at
--   <a>https://github.com/AdamLassiter/lambda-cube#readme</a>
@package lambda-cube
@version 0.3.0

module L3.Core.Expr

-- | An expression in the calculus of constructions.
data Expr a
Star :: Expr a
Box :: Expr a
Var :: a -> Expr a
Lam :: a -> Expr a -> Expr a -> Expr a
Pi :: a -> Expr a -> Expr a -> Expr a
App :: Expr a -> Expr a -> Expr a

-- | A context is a stack, mapping names to bound values.
data Context a
Ctx :: [(a, Expr a)] -> Context a
instance Data.Foldable.Foldable L3.Core.Expr.Expr
instance GHC.Base.Functor L3.Core.Expr.Expr
instance Data.Traversable.Traversable L3.Core.Expr.Expr
instance GHC.Classes.Eq a => GHC.Classes.Eq (L3.Core.Expr.Expr a)


-- | Safe and unsafe logging functions wrapping Control.Logging
module L3.Log.Colors
reset :: String
black :: String
red :: String
green :: String
yellow :: String
blue :: String
magenta :: String
cyan :: String
white :: String
brightBlack :: String
brightRed :: String
brightGreen :: String
brightYellow :: String
brightBlue :: String
brightMagenta :: String
brightCyan :: String
brightWhite :: String


-- | Safe and unsafe logging functions wrapping Control.Logging
module L3.Log.Logging
logId :: (String -> String -> IO ()) -> String -> String -> a -> IO a
traceU :: String -> String -> a -> a
debugM :: String -> String -> IO ()
debugU :: String -> String -> a -> a
infoM :: String -> String -> IO ()
infoU :: String -> String -> a -> a
warnM :: String -> String -> IO ()
warnU :: String -> String -> a -> a
errorU :: String -> String -> a
data LogLevel
LevelDebug :: LogLevel
LevelInfo :: LogLevel
LevelWarn :: LogLevel
LevelError :: LogLevel
withStderrLogging :: (MonadBaseControl IO m, MonadIO m) => m a -> m a
withStdoutLogging :: (MonadBaseControl IO m, MonadIO m) => m a -> m a
withFileLogging :: (MonadBaseControl IO m, MonadIO m) => FilePath -> m a -> m a
setLogLevel :: LogLevel -> IO ()
setDebugSourceRegex :: String -> IO ()

module L3.Log

module L3.Parse.Parser
newtype Parser i o
Parser :: (i -> [(o, i)]) -> Parser i o
[parse] :: Parser i o -> i -> [(o, i)]
bind :: Parser i o -> (o -> Parser i o') -> Parser i o'
unit :: o -> Parser i o
combine :: Parser i o -> Parser i o -> Parser i o
failure :: Parser i o
option :: Parser i o -> Parser i o -> Parser i o
instance GHC.Base.Functor (L3.Parse.Parser.Parser i)
instance GHC.Base.Applicative (L3.Parse.Parser.Parser i)
instance GHC.Base.Monad (L3.Parse.Parser.Parser i)
instance GHC.Base.MonadPlus (L3.Parse.Parser.Parser i)
instance GHC.Base.Alternative (L3.Parse.Parser.Parser i)


-- | Utilites for result types and error throwing
module L3.Util.Util
newtype Error
Error :: ([String], Maybe Error) -> Error
type Result a = Either Error a
showIndent :: Show a => a -> String
throw :: Error -> Result a
throwError :: [String] -> Error
rethrowError :: [String] -> Error -> Error
unpack :: [Result a] -> Result [a]
mapL :: (Error -> Error) -> Result a -> Result a
mapR :: (a -> b) -> Result a -> Result b
fmapR :: (a -> Result b) -> Result a -> Result b
flatten :: Result (Result a) -> Result a
throwL :: Result a -> a
isError :: Result a -> Bool
instance GHC.Classes.Eq L3.Util.Util.Error
instance GHC.Show.Show L3.Util.Util.Error

module L3.Util


-- | Small parsec-like module
module L3.Parse.Parsec
unParser :: Parser i o -> i -> [(o, i)]
runParser :: (Alternative f, Show (f i), Show o, Eq (f i)) => Parser (f i) o -> f i -> Result o
some :: Alternative f => f a -> f [a]
many :: Alternative f => f a -> f [a]
chainl :: Parser i o -> Parser i (o -> o -> o) -> o -> Parser i o
chainl1 :: Parser i o -> Parser i (o -> o -> o) -> Parser i o


-- | Parsec utils for parsing Strings into Strings
module L3.Parse.StringParsec
item :: Parser String Char
satisfy :: (Char -> Bool) -> Parser String Char
oneOf :: String -> Parser String Char
char :: Char -> Parser String Char
letter :: Parser String Char
natural :: Parser String Integer
string :: String -> Parser String String
token :: Parser String a -> Parser String a
reserved :: String -> Parser String String
space :: Parser String Char
spaces :: Parser String String
digit :: Parser String Char
number :: Parser String Int
word :: Parser String String


-- | Lexer from Strings into Tokens
module L3.Parse.Lexer

-- | Lex strings into tokens, canonical form for the syntax definitition
data Token
OpenParen :: Token
CloseParen :: Token
OpenBracket :: Token
CloseBracket :: Token
HasType :: Token
At :: Token
StarT :: Token
BoxT :: Token
Arrow :: Token
LambdaT :: Token
PiT :: Token
AutoT :: Token
Symbol :: String -> Token
Number :: Int -> Token
Comment :: String -> Token
EOL :: Token

-- | A list of Alternatives that may be used to lex a string into tokens.
alternatives :: [Parser String Token]

-- | Parse a comment, taking characters until an End-Of-Line
comment :: Parser String Token

-- | Parse a string into canonical form using tokens
lexSrc :: String -> Result [Token]

-- | The grammar for this parser is the collection of Alternatives
grammar :: Parser String [Token]
instance GHC.Classes.Eq L3.Parse.Lexer.Token
instance GHC.Show.Show L3.Parse.Lexer.Token


-- | Parsec utils for parsing Tokens into Tokens
module L3.Parse.TokenParsec
item :: Parser [Token] Token
satisfy :: (Token -> Bool) -> Parser [Token] Token
one :: Token -> Parser [Token] Token
oneOf :: [Token] -> Parser [Token] Token
token :: Parser [Token] a -> Parser [Token] a
reserved :: Token -> Parser [Token] Token
number :: Parser [Token] Token
symbol :: Parser [Token] Token
parens :: Parser [Token] a -> Parser [Token] a
brackets :: Parser [Token] a -> Parser [Token] a
parentheses :: Parser [Token] a -> Parser [Token] a


-- | Type checking and type inference
module L3.Core.Show
newtype Name
Name :: String -> Name
type ShowExpr = Expr Name

-- | Show an expression
showExpr :: Show a => Expr a -> String
type ShowCtx = Context Name

-- | Show for a context, printing each binding on a separate line.
showCtx :: Show a => Context a -> String
instance GHC.Classes.Eq L3.Core.Show.Name
instance GHC.Enum.Enum L3.Core.Show.Name
instance GHC.Show.Show L3.Core.Show.Name
instance (GHC.Enum.Enum a, GHC.Enum.Enum b) => GHC.Enum.Enum (Data.Either.Either a b)
instance GHC.Show.Show a => GHC.Show.Show (L3.Core.Expr.Expr a)
instance GHC.Show.Show a => GHC.Show.Show (L3.Core.Expr.Context a)


-- | Type checking and type inference
module L3.Core.Normal

-- | Is a name <a>free</a> in an expression In this context, free v a &amp;
--   v <i>= v' =&gt; substitute v v' a </i>= a i.e. would a substitution be
--   performed
free :: (Eq a, Show a) => a -> Expr a -> Bool
fresh :: (Eq a, Enum a, Show a) => a -> Expr a -> a

-- | Substitute all occurrences of a variable v with an expression e.
--   substitute v e E ~ E[v := e]
substitute :: (Eq a, Enum a, Show a) => a -> Expr a -> Expr a -> Expr a

-- | Given an expression, reduce it one step towards its normal form.
normalize :: (Eq a, Enum a, Show a) => Expr a -> Expr a

-- | Given an expression, totally reduce it over all steps towards normal
--   form.
normalize0 :: (Eq a, Enum a, Show a) => Expr a -> Expr a


-- | Type checking and type inference
module L3.Core.DeBruijn

-- | Given an <a>free</a> index, convert an expression in Right names into
--   Left indexes. This uses DeBruijn indicies.
index :: (Eq a, Enum a, Show a) => Int -> Expr (Either Int a) -> Expr (Either Int a)

-- | Provide an initial <a>free</a> index of 0 and index an expression.
--   This converts any expression to its DeBruijn indexed form, leaving
--   global names untouched.
index0 :: (Eq a, Enum a, Show a) => Expr a -> Expr (Either Int a)


-- | Type checking and type inference
module L3.Core.Eq

-- | Deduce whether two expressions are equivalent by converting to indexed
--   form and checking for exact equality. This does not apply
--   normalisation, so represents only alpha-equivalence of expressions.
alphaEq :: (Eq a, Enum a, Show a) => Expr a -> Expr a -> Bool

-- | Deduce whether two expressions are equivalent by converting to indexed
--   form and checking for exact equality. This does apply normalisation,
--   so represents beta-equivalence (and implicitly alpha-equivalence) of
--   expressions.
betaEq :: (Eq a, Enum a, Show a) => Expr a -> Expr a -> Bool


-- | Type checking and type inference
module L3.Core.Infer

-- | Type-check an expression and return the expression's type if
--   type-checking | succeeds or an error message if type-checking fails |
--   <a>inferType</a>` does not necessarily normalize the type since full
--   normalization | is not necessary for just type-checking. If you
--   actually care about the | returned type then you may want to
--   <a>normalize</a> it afterwards. | Type inference is within a type
--   context (list of global names and their types) | | <tt>Weak</tt> type
--   infernce here refers to the lack of partial evaluation for contextual
--   | beta-equivalence. For some X, a by-value and by-reference of X
--   should be legal: | (λ (T : *) . λ (f : π (X : *) . X) . λ (x : T) . f
--   x) X | In fact, resolving T := X as beta-equivalent to X will fail for
--   weakInferType.
weakInferType :: (Eq a, Enum a, Show a) => Context a -> Expr a -> Result (Expr a)

-- | Type-check an expression and return the expression's normalized type
--   if | type-checking succeeds or an error message if type-checking fails
inferType :: (Eq a, Enum a, Show a) => Context a -> Expr a -> Result (Expr a)

-- | <a>inferType0</a> is the same as <a>inferType</a> with an empty
--   context, meaning that | the expression must be closed (i.e. no free
--   variables), otherwise type-checking | will fail.
inferType0 :: (Eq a, Enum a, Show a) => Expr a -> Result (Expr a)

-- | Type-check an expression and return the expression's normalized type
--   if | type-checking succeeds or an error message if type-checking fails
--   | Perform partial evaluation by substitution of lambda-applications to
--   types | to ensure the problem-case for <a>weakInferType</a> does not
--   fail here.
inferType1 :: (Eq a, Enum a, Show a) => Context a -> Expr a -> Result (Expr a)

-- | Deduce if an expression e is well-typed - i.e. its type can be
--   inferred.
wellTyped :: (Eq a, Enum a, Show a) => Context a -> Expr a -> Bool

-- | Deduce if an expression is well-typed context-free - i.e. it is
--   additionally | closed and therefore well-typed without additional
--   context.
wellTyped0 :: (Eq a, Enum a, Show a) => Expr a -> Bool


-- | Type checking and type inference
module L3.Core.Eval

-- | Evaluate an expression, returning its type and normalized form
evalExpr :: (Eq a, Enum a, Show a) => Context a -> Expr a -> Result (Expr a, Expr a)

-- | <a>evalExpr0</a> is the same as <a>evalExpr</a> with an empty context,
--   meaning that the expression must be closed (i.e. no free variables),
--   otherwise evaluation will fail.
evalExpr0 :: (Eq a, Enum a, Show a) => Expr a -> Result (Expr a, Expr a)

module L3.Core


-- | Parser from Tokens into Expressions
module L3.Parse.ExprParser

-- | Parse a string to a named expression (using string labels) Strip
--   comments here, as they apply inside any context and are difficult to
--   deal with otherwise
parseExpr :: [Token] -> Result ShowExpr

module L3.Parse


-- | Load and parse '.l3' files
module L3.Loader.Loader

-- | Fold the prelude context through lambda application into a
--   type-context and expression-context-mapper. That is, `let a = x in b`
--   <a>=</a> `(λ a -&gt; b) x`
wrapPrelude :: [(FilePath, ByteString)] -> (ShowCtx, ShowExpr -> ShowExpr)

-- | Embed and retrieve all '.l3' files in the prelude directory
embeddedPrelude :: [(FilePath, ByteString)]
embeddedPreludeIO :: IO [(FilePath, ByteString)]

-- | Get the last directory name from a path
takeDirectoryName :: FilePath -> String

-- | Format a file into either non-namespaced <tt>file</tt> or namespaced
--   <tt>dir</tt>@<tt>file</tt>
takeNamespacedFileName :: FilePath -> String

-- | Lex and parse the prelude into a type-context and expression-context
loadPrelude :: [(FilePath, ByteString)] -> (ShowCtx, ShowCtx)

-- | Substitute all occurrences of a variable v with an expression e, but
--   only where v appears in a type.
tauSubst :: (Eq a, Enum a, Show a) => a -> Expr a -> Expr a -> Expr a

-- | Partially evaluate the types of an expression through
--   lambda-application substitutions. This should remain correct, but
--   allows for binding types and evaluating by-reference.
tauNorm :: (Eq a, Enum a, Show a) => Expr a -> Expr a

module L3.Loader
